Подводные камни
===============

Данное руководство объясняет некоторые особенности работы библиотеки. Как html5 audio, так и flash являются весьма
нестабильными технологиями и имеют разную поддержку в разных браузерах. Большую часть этих проблем данная библиотека 
решает, но всё равно остаются вещи, которые нельзя победить с помощью js или которые совершенно не очевидны.

Flash
-----

### Flash и овелей
Существует минимум 2 проблемы с flash, которые не возможно 100% продиагностировать с помощью js:
  - узнать точную версию flash-плеера
  - узнать есть ли блокировщик flash в браузере
  
Узнать точную версию flash нельзя т.к. некоторые плагины для браузеров выводят совершенно неадекватные номера версий.
Встречались случаи, когда номер версии был 99.999.999 или наоборот 0.0.0. С блокировщиками flash ситуация вообще
плохая - некоторые блокировщики специально стараются замаскировать своё присутствие, другие просто не очень корректно
производят блокировку (например позволяют flash-апплету полностью загрузиться и даже выполнить какой-то код и лишь
после этого блокируют их). Плюс к тому если flash-апплет невидим, то у пользователя нет никакой возможности вообще
узнать о факте блокировки и тем более нет возможности разблокировать его.

Для решения данной проблемы конструктор плеера принимает в качестве необязательного аргумента html-элемент для
отображения оверлея. В этот оверлей помещается прозрачный flash-апплет плеера. Это позволяет в случае необходимости
показать пользователю, что flash-блокировщик нашкодил и его нужно отключить. Большая часть блокировщиков позволяют
отменять блокировку простым кликом по данному элементу, поэтому плеер прослушивает событие клика и если после него 
flash-апплет по прежнему оказывается недоступен по истечении некоторого времени, плеер пытается применить другую
технологию воспроизведения или перезагружает апплет.

***ВАЖНО!*** После успешной инициализации плеера, чтобы скрыть уже не нужный оверлей его нельзя просто удалять из DOM'а,
т.к. в нём по прежнему содержится flash-апплет. После его удаления плеер перейдёт в нерабочее состояние. Также нельзя
применять к данному оверлею стиль `display: none` - это заблокирует доступ к flash-апплету. Для скрытия оверлея
можно например использовать следующие css-стили:

```css
  position: absolute;
  top: -9999px;
  left: -9999px;
```

### Некоторые особенности flash
Во flash-реализации плеера есть несколько особенностей про которые стоит знать.

 1. flash-апплет является синглтоном. При создании любого количества плееров с внутренним типом flash - апплет
 будет загружен и включён в страницу только один раз. Сам апплет является чем-то вроде фабрики и моста одновременно.
 Он создаёт во flash окружении инстансы flash-плееров и комутирует запросы и события связанные с этими плеерами.
 У этого решения есть как плюсы так и минусы:
  
  - существенно меньше потребление памяти при использовании нескольких плееров на странице
  - при наличии флеш-блокеров инициализация требуется всего один раз для любого количества плееров
  - при крахе апплета "умрут" сразу все плееры, которые используют flash-реализацию (такое пока не наблюдалось, но
 вероятность всё же существует)
  
 2. Текущая реализация flash-плеера достаточно проста и потому имеет одно ограничение: нельзя ставить позицию
 воспроизведения дальше загруженной части трека. При установке позиции воспроизведения следует всегда считывать
 возвращаемое значение - оно будет отражать реальную позицию на которую было установлено воспроизведение (или как
 вариант полагаться только на события обновления позиции воспроизведения).

HTML5
-----

### HTML5 и мобильные браузеры
В мобильных браузерах есть сразу несколько проблем с воспроизведением звука в html5 audio элементе. 

 1. Элементы audio начинают работать и воспроизводить звук, только если команда play была вызвана внутри обработчика
 пользовательского события. Это поведние присутствует также и в большинстве десктопных браузеров Задачу начальной
 инициализации библиотека берёт на себя, прослушивая события keydown, mousedown, и touchstart на объекте body. 
 К счастью это требуется выполнить лишь один раз, далее можно спокойно пользоваться элементом.
  
 2. Мобильные браузеры совсем неадекватно себя ведут, когда на странице присутствует 2 и более элементов audio:
 
  - Только один элемент может быть активным. Если запустить воспроизведение во втором, то в первом оно остановится.
  - После такого сценария остановки первый элемент "умирает". Повторная попытка запустить воспроизведение в этом
  элементе не делает вообще ничего, даже не вызывает ошибки. От этого помогает только вызов на первом элементе 
  метода load.
  - Даже если трек полностью закешировался, даже если ссылка в элементе audio не менялась повторный вызов метода load
   повторно загрузит трек снуля. Никакое кеширование не применяется.
    
 В данной библиотеке есть средства для "борьбы" с данными проблемами браузеров - при запуске воспроизведения трека
 скрипт следит за процессом загрузки и обновления позиции воспроизведения и если воспроизведение на самом деле не
 начинается, то скрипт перезагружает трек и запускает воспроизведение заново с точки на которой оно остановилось.
 Следует учитывать данное поведение при отладке поведения плеера - иначе можно по меньшей мере сильно удивиться увидев
 беспричинную перезагрузку трека.
  
 3. Некоторые мобильные браузеры запрещают элементу audio изменять громкость. Для того, чтобы проверить есть ли
 возможность программного изменения громкости сделан метод isDeviceVolume.
  
### Web Audio API
Технология Web Audio API самая новая из всех перечисленных, но самая перспективная. В данный момент, правда с её
использованием существует несколько существенных проблем

 1. Для применения Web Audio API при воспроизведения треков со стороннего домена, требуется чтобы медиа-файлы приходили
 с правильным заголовком Access-Control-Allow-Origin, иначе Web Audio API не сможет получить доступ к данным трека. При
 этом в разных браузерах это приводит к разным результатам, одни браузеры просто ничего не делают, в других наступает
 тишина. Если планируется динамически подключать web audio api во время воспроизведения трека, следует заранее включить
 режим CORS (метод toggleCrossDomain) - в противном случае потребуется перезагрузить трек после включения этого режима,
 более того - в FF 39 обнаружена ошибка, при которой даже перезагрузка трека не обеспечивает корректной
 работы Web Audio API.
 
 ***ВАЖНО!*** - если включить режим CORS, аудио элемент не сможет загружать
 данные со сторонних доменов, если в ответе не будет правильного заголовка Access-Control-Allow-Origin. Если не
 планируется использование Web Audio API, не стоит включать этот режим.
  
 2. Web Audio API не работает в мобильных браузерах, хотя удаётся создать контекст и при создании различных AudioNode
 не возникает никаких ошибок и нормально воспроизводится звук. Поэтому для мобильных браузеров Web Audio API превентивно
 отключен.

 3. Web Audio API может существенно увеличить нагрузку на CPU, в т.ч. вызвать "заикание" звука. Стоит давать 
 пользователю возможность отключения этого функционала.
